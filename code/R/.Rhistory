pred.class.kfold <- predict(gridsearch, x_login)
grd_login_pos <- sum(pred.class.kfold == df.login.y)
grd_login_neg <- sum(pred.class.kfold != df.login.y)
grd_login_acc <- grd_login_pos / length(df.login.y)
pred.prob.kfold <- predict(gridsearch, x_login, type = 'prob')
max.probs.login.kfold <- apply(pred.prob.kfold, 1, max, na.rm=TRUE)
matched.kfold <- pred.class.kfold == df.login.y
grd_login_pos_prob <- sum(matched.kfold[max.probs.login.kfold> 0.5])
grd_login_neg_prob <- length(df.login.y) - grd_login_pos_prob
# attack
pred.prob.attack.kfold <- predict(gridsearch, x_val, type = 'prob')
max.probs.kfold <- apply(pred.prob.attack.kfold, 1, max, na.rm=TRUE) # max by row
grd_attack_pos <- sum(max.probs.kfold > 0.5)
grd_attack_neg <- length(max.probs.kfold) - grd_attack_pos
df.results[row,] <- c(pc_train, iter, num_users,
num_attackers,
num_variables,
login_pos,
login_neg,
login_pos_prob,
login_neg_prob,
attack_pos,
attack_neg,
grd_login_pos,
grd_login_neg,
grd_login_pos_prob,
grd_login_neg_prob,
grd_attack_pos,
grd_attack_neg
)
row <- row + 1
}
}
View(df.results)
write.csv(df.results,'result32-key')
USE_SENSOR_DATA <-F
if (USE_SENSOR_DATA == T){
sensors.login <- loadSensorsLogin()
}
iters <- c(0,1)
row <- 1
for (pc_train in percents){
# iter
# 0: train/test:[1-5], val:6
# 1: train/test:[1-5], val:7
for (iter in iters){
# split train and attack's validation
session_start <- 1 + iter
session_end <- NUM_SESSIONS + iter
ind <- round(length(ids) * pc_train)
ids.train <-ids[1:ind]
ids.val <-ids[(ind+1):length(ids)]
num_users <- length(ids.train)
num_attackers <- length(ids.val)
##########################
# I- template (training) #
##########################
keyboard.train <- keyboard_login %>%
filter(user_id %in% ids.train)
if (USE_SENSOR_DATA == T){
sensors.train <- sensors.login  %>%
filter(user_id %in% ids.train)
}
keyboard.grouped <- keyboard.train %>%
filter(action_number >= session_start,
action_number <= session_end) %>%
group_by(user_id, character, action_number)
keyboard.stats <- getCharStats(keyboard.grouped)
info.keyboard.cols <- infoGainCols(keyboard.stats)
keyboard.stats <- keyboard.stats[c("user_id", info.keyboard.cols)]
info.cols <- info.keyboard.cols
info.sensor.cols = NULL
if (USE_SENSOR_DATA == T){
sensors.train.grouped <- sensors.train %>%
filter(action_number >= session_start,
action_number <= session_end) %>%
group_by(user_id, action_number)
sensors.stats <- sensorStats(sensors.train.grouped)
info.sensor.cols <- infoGainCols(sensors.stats)
sensors.stats <- sensors.stats[info.sensor.cols]
keyboard.stats <- bind_cols(keyboard.stats, sensors.stats)
info.cols <- c(info.keyboard.cols, info.keyboard.cols)
}
card.train <- keyboard.stats
num_variables <- length(info.cols) -1
##############
# II - login #
##############
keyboard.login <- keyboard.train %>%
filter(action_number == session_end + 1) %>%
group_by(user_id, character, action_number)
keyboard.login.stats <- getCharStats(keyboard.login)
keyboard.login.stats <- keyboard.login.stats[
c("user_id", info.keyboard.cols)]
if (USE_SENSOR_DATA == T){
sensor.login.grouped <- sensors.train %>%
filter(action_number == session_end + 1) %>%
group_by(user_id, action_number)
sensors.login.stats <- sensorStats(sensor.login.grouped)
sensors.login.stats <- sensors.login.stats[info.sensor.cols]
keyboard.login.stats <- bind_cols(keyboard.login.stats,
sensors.login.stats)
}
card.login <- keyboard.login.stats
####################
# III - validation #
####################
keyboard.val <- keyboard_login %>%
filter(user_id %in% ids.val)
if (USE_SENSOR_DATA == T){
sensors.val <- sensors.login %>%
filter(user_id %in% ids.val)
}
keyboard.val.grouped <- keyboard.val %>%
group_by(user_id, character, action_number)
keyboard.val.stats <- getCharStats(keyboard.val.grouped, secao = T)
keyboard.val.stats <- keyboard.val.stats[c("user_id", info.keyboard.cols)]
if (USE_SENSOR_DATA == T){
sensor.val.grouped <- sensors.val %>% group_by(user_id, action_number)
sensors.val.stats <- sensorStats(sensor.val.grouped)
sensors.val.stats <- sensors.val.stats[info.sensor.cols]
keyboard.val.stats <- bind_cols(keyboard.val.stats, sensors.val.stats)
}
card.val <- keyboard.val.stats
###############
### TRAIN #####
###############
x_train <- card.train[,-1]
y_train <- as.factor(card.train$user_id)
x_login <- card.login[,-1]
y_login <- as.factor(card.login$user_id)
x_val <- card.val[,-1]
y_val <- as.factor(card.val$user_id)
# randomForest class w/ 5 sections
rf <- randomForest(
x_train,
y_train,
importance = T)
# with k-fold
df.train <- card.train
df.train$user_id <- paste("u", df.train$user_id, sep = "")
control <- trainControl(method = "repeatedcv",
number = 10 ,
repeats = 2,
search = "grid",
classProbs = T)
gridsearch <- train(
user_id ~ .,
data = df.train ,
method = 'rf',
ntree = 100,
trControl = control
)
# I. login try
pred.class.login <- predict(object = rf, x_login, type ="class")
login_pos <- sum(pred.class.login == y_login)
login_neg <- sum(pred.class.login != y_login)
pred.prob.login <- predict(object = rf, x_login, type ="prob")
max.probs.login <- apply(pred.prob.login, 1, max)
matched <- pred.class.login == y_login
login_pos_prob <- sum(matched[max.probs.login> 0.5])
login_neg_prob <- length(pred.class.login) - login_pos_prob
# II. attack try
pred.prob.val <- predict(object = rf, x_val, type ="prob")
max.probs <- apply(pred.prob.val, 1, max, na.rm=TRUE)
attack_pos <- sum(max.probs > 0.5)
attack_neg <- length(max.probs) - attack_pos
# II. gridsearch
# login
df.login.y <- paste("u", y_login, sep = "")
pred.class.kfold <- predict(gridsearch, x_login)
grd_login_pos <- sum(pred.class.kfold == df.login.y)
grd_login_neg <- sum(pred.class.kfold != df.login.y)
grd_login_acc <- grd_login_pos / length(df.login.y)
pred.prob.kfold <- predict(gridsearch, x_login, type = 'prob')
max.probs.login.kfold <- apply(pred.prob.kfold, 1, max, na.rm=TRUE)
matched.kfold <- pred.class.kfold == df.login.y
grd_login_pos_prob <- sum(matched.kfold[max.probs.login.kfold> 0.5])
grd_login_neg_prob <- length(df.login.y) - grd_login_pos_prob
# attack
pred.prob.attack.kfold <- predict(gridsearch, x_val, type = 'prob')
max.probs.kfold <- apply(pred.prob.attack.kfold, 1, max, na.rm=TRUE) # max by row
grd_attack_pos <- sum(max.probs.kfold > 0.5)
grd_attack_neg <- length(max.probs.kfold) - grd_attack_pos
df.results[row,] <- c(pc_train, iter, num_users,
num_attackers,
num_variables,
login_pos,
login_neg,
login_pos_prob,
login_neg_prob,
attack_pos,
attack_neg,
grd_login_pos,
grd_login_neg,
grd_login_pos_prob,
grd_login_neg_prob,
grd_attack_pos,
grd_attack_neg
)
row <- row + 1
}
}
View(df.results)
write.csv(df.results,'result32-key-sens')
USE_SENSOR_DATA
USE_SENSOR_DATA <-T
if (USE_SENSOR_DATA == T){
sensors.login <- loadSensorsLogin()
}
iters <- c(0,1)
row <- 1
for (pc_train in percents){
# iter
# 0: train/test:[1-5], val:6
# 1: train/test:[1-5], val:7
for (iter in iters){
# split train and attack's validation
session_start <- 1 + iter
session_end <- NUM_SESSIONS + iter
ind <- round(length(ids) * pc_train)
ids.train <-ids[1:ind]
ids.val <-ids[(ind+1):length(ids)]
num_users <- length(ids.train)
num_attackers <- length(ids.val)
##########################
# I- template (training) #
##########################
keyboard.train <- keyboard_login %>%
filter(user_id %in% ids.train)
if (USE_SENSOR_DATA == T){
sensors.train <- sensors.login  %>%
filter(user_id %in% ids.train)
}
keyboard.grouped <- keyboard.train %>%
filter(action_number >= session_start,
action_number <= session_end) %>%
group_by(user_id, character, action_number)
keyboard.stats <- getCharStats(keyboard.grouped)
info.keyboard.cols <- infoGainCols(keyboard.stats)
keyboard.stats <- keyboard.stats[c("user_id", info.keyboard.cols)]
info.cols <- info.keyboard.cols
info.sensor.cols = NULL
if (USE_SENSOR_DATA == T){
sensors.train.grouped <- sensors.train %>%
filter(action_number >= session_start,
action_number <= session_end) %>%
group_by(user_id, action_number)
sensors.stats <- sensorStats(sensors.train.grouped)
info.sensor.cols <- infoGainCols(sensors.stats)
sensors.stats <- sensors.stats[info.sensor.cols]
keyboard.stats <- bind_cols(keyboard.stats, sensors.stats)
info.cols <- c(info.keyboard.cols, info.keyboard.cols)
}
card.train <- keyboard.stats
num_variables <- length(info.cols) -1
##############
# II - login #
##############
keyboard.login <- keyboard.train %>%
filter(action_number == session_end + 1) %>%
group_by(user_id, character, action_number)
keyboard.login.stats <- getCharStats(keyboard.login)
keyboard.login.stats <- keyboard.login.stats[
c("user_id", info.keyboard.cols)]
if (USE_SENSOR_DATA == T){
sensor.login.grouped <- sensors.train %>%
filter(action_number == session_end + 1) %>%
group_by(user_id, action_number)
sensors.login.stats <- sensorStats(sensor.login.grouped)
sensors.login.stats <- sensors.login.stats[info.sensor.cols]
keyboard.login.stats <- bind_cols(keyboard.login.stats,
sensors.login.stats)
}
card.login <- keyboard.login.stats
####################
# III - validation #
####################
keyboard.val <- keyboard_login %>%
filter(user_id %in% ids.val)
if (USE_SENSOR_DATA == T){
sensors.val <- sensors.login %>%
filter(user_id %in% ids.val)
}
keyboard.val.grouped <- keyboard.val %>%
group_by(user_id, character, action_number)
keyboard.val.stats <- getCharStats(keyboard.val.grouped, secao = T)
keyboard.val.stats <- keyboard.val.stats[c("user_id", info.keyboard.cols)]
if (USE_SENSOR_DATA == T){
sensor.val.grouped <- sensors.val %>% group_by(user_id, action_number)
sensors.val.stats <- sensorStats(sensor.val.grouped)
sensors.val.stats <- sensors.val.stats[info.sensor.cols]
keyboard.val.stats <- bind_cols(keyboard.val.stats, sensors.val.stats)
}
card.val <- keyboard.val.stats
###############
### TRAIN #####
###############
x_train <- card.train[,-1]
y_train <- as.factor(card.train$user_id)
x_login <- card.login[,-1]
y_login <- as.factor(card.login$user_id)
x_val <- card.val[,-1]
y_val <- as.factor(card.val$user_id)
# randomForest class w/ 5 sections
rf <- randomForest(
x_train,
y_train,
importance = T)
# with k-fold
df.train <- card.train
df.train$user_id <- paste("u", df.train$user_id, sep = "")
control <- trainControl(method = "repeatedcv",
number = 10 ,
repeats = 2,
search = "grid",
classProbs = T)
gridsearch <- train(
user_id ~ .,
data = df.train ,
method = 'rf',
ntree = 100,
trControl = control
)
# I. login try
pred.class.login <- predict(object = rf, x_login, type ="class")
login_pos <- sum(pred.class.login == y_login)
login_neg <- sum(pred.class.login != y_login)
pred.prob.login <- predict(object = rf, x_login, type ="prob")
max.probs.login <- apply(pred.prob.login, 1, max)
matched <- pred.class.login == y_login
login_pos_prob <- sum(matched[max.probs.login> 0.5])
login_neg_prob <- length(pred.class.login) - login_pos_prob
# II. attack try
pred.prob.val <- predict(object = rf, x_val, type ="prob")
max.probs <- apply(pred.prob.val, 1, max, na.rm=TRUE)
attack_pos <- sum(max.probs > 0.5)
attack_neg <- length(max.probs) - attack_pos
# II. gridsearch
# login
df.login.y <- paste("u", y_login, sep = "")
pred.class.kfold <- predict(gridsearch, x_login)
grd_login_pos <- sum(pred.class.kfold == df.login.y)
grd_login_neg <- sum(pred.class.kfold != df.login.y)
grd_login_acc <- grd_login_pos / length(df.login.y)
pred.prob.kfold <- predict(gridsearch, x_login, type = 'prob')
max.probs.login.kfold <- apply(pred.prob.kfold, 1, max, na.rm=TRUE)
matched.kfold <- pred.class.kfold == df.login.y
grd_login_pos_prob <- sum(matched.kfold[max.probs.login.kfold> 0.5])
grd_login_neg_prob <- length(df.login.y) - grd_login_pos_prob
# attack
pred.prob.attack.kfold <- predict(gridsearch, x_val, type = 'prob')
max.probs.kfold <- apply(pred.prob.attack.kfold, 1, max, na.rm=TRUE) # max by row
grd_attack_pos <- sum(max.probs.kfold > 0.5)
grd_attack_neg <- length(max.probs.kfold) - grd_attack_pos
df.results[row,] <- c(pc_train, iter, num_users,
num_attackers,
num_variables,
login_pos,
login_neg,
login_pos_prob,
login_neg_prob,
attack_pos,
attack_neg,
grd_login_pos,
grd_login_neg,
grd_login_pos_prob,
grd_login_neg_prob,
grd_attack_pos,
grd_attack_neg
)
row <- row + 1
}
}
View(df.results)
write.csv(df.results,'result32-key-sens')
View(keyboard.stats)
View(keyboard.stats)
info.keyboard.cols
View(keyboard.stats)
View(keyboard.stats)
View(keyboard.grouped)
keyboard.stats <- getCharStats(keyboard.grouped)
View(keyboard.stats)
15 * 5
15 * 5 * 8
15 * 5
15 * 5 * 8
dbase <- keyboard.grouped
secao <- T
groupby <- c("user_id")
ini.range <- 3
if (secao == T){
groupby <- c("user_id","action_number")
ini.range <- 4
}
groupby <- c("user_id")
ini.range <- 3
if (secao == T){
groupby <- c("user_id","action_number")
ini.range <- 4
}
ini.range
desc_login_char_5 <- keyboardStats(dbase, 5)
desc_login_char_4 <- keyboardStats(dbase, 4)
desc_login_char_8 <- keyboardStats(dbase, 8)
desc_login_char_3 <- keyboardStats(dbase, 3)
desc_login_char_1 <- keyboardStats(dbase, 1)
desc_login_char_7 <- keyboardStats(dbase, 7)
desc_login_char_9 <- keyboardStats(dbase, 9)
desc_login_char_0 <- keyboardStats(dbase, 0)
col.names <- names(desc_login_char_5)
col.names
col.names <- col.names[ini.range:length(col.names)]
col.names
length(col.names)
15 * 5
74 * 8
keyboardStats <- function(dfdata, digit){
card_stats <- dfdata %>%
filter(character == digit) %>%
mutate(
fly_time = ifelse(pointer_event_type == 1, time_diff, NA) ,
dwell_time = ifelse(pointer_event_type != 1, press_time_diff, NA) ,
) %>%
summarise(
# DT Dwelling Time
dt_md = median(dwell_time, na.rm = T),
dt_fq = qt(dwell_time, 1),
dt_tq = qt(dwell_time, 3),
dt_ir = IQR(dwell_time, na.rm = T),
dt_ma = mean(dwell_time, na.rm = T),
dt_vr = var(dwell_time, na.rm = T),
dt_sd = sd(dwell_time, na.rm = T),
dt_cv = cv(dwell_time, na.rm = T),
dt_se = se(dwell_time),
dt_mn = min(dwell_time, na.rm = T) ,
dt_mx = max(dwell_time, na.rm = T) ,
dt_qm = qm(dwell_time) ,
dt_rg = rg(dwell_time) ,
dt_sk = skewness(dwell_time) ,
dt_ku = kurtosis(dwell_time) ,
# FT Flight Time
ft_md = median(fly_time, na.rm = T),
ft_fq = qt(fly_time, 1),
ft_tq = qt(fly_time, 3),
ft_ir = IQR(fly_time, na.rm = T),
ft_am = mean(fly_time, na.rm = T),
ft_vr = var(fly_time, na.rm = T),
ft_sd = sd(fly_time, na.rm = T),
ft_cv = cv(fly_time, na.rm = T),
ft_se = se(fly_time),
ft_mn = min(fly_time , na.rm = T) ,
ft_mx = max(fly_time, na.rm = T) ,
ft_qm = qm(fly_time) ,
ft_rg = rg(fly_time) ,
ft_sk = skewness(fly_time) ,
ft_ku = kurtosis(fly_time) ,
# Pressure
ps_md = median(pressure),
ps_fq = qt(pressure, 1),
ps_tq = qt(pressure, 3),
ps_ir = IQR(pressure, na.rm = T),
ps_am = mean(pressure, na.rm = T),
ps_var = var(pressure, na.rm = T),
ps_sd = sd(pressure, na.rm = T),
ps_cv = cv(pressure, na.rm = T),
ps_se = se(pressure),
ps_mn = min(pressure),
ps_mx = max(pressure),
ps_qm = qm(pressure) ,
ps_rg = rg(pressure) ,
ps_sk = skewness(pressure) ,
ps_ku = kurtosis(pressure) ,
# Spacial x
x_md = median(x, na.rm = T),
x_fq = qt(x, 1),
x_tq = qt(x, 3),
x_ir = IQR(x, na.rm = T),
x_am = mean(x, na.rm = T),
x_vr = var(x, na.rm = T),
x_sd = sd(x, na.rm = T),
x_cv = cv(x, na.rm = T),
x_se = se(x),
x_mn = min(x, na.rm = T) ,
x_mx = max(x, na.rm = T) ,
x_qm = qm(x) ,
x_rg = rg(x),
x_sk =  skewness(x) ,
x_ku = kurtosis(x) ,
# Spacial y
y_md = median(y, na.rm = T),
y_fq = qt(y, 1),
y_tq = qt(y, 3),
y_ir = IQR(y, na.rm = T),
y_am = mean(y, na.rm = T),
y_vr = var(y),
y_sd = sd(y, na.rm = T),
y_cv = cv(y, na.rm = T),
y_se = se(y),
y_mn = min(y, na.rm = T) ,
y_mx = max(y, na.rm = T) ,
y_qm = qm(y),
y_rg =  rg(y) ,
y_sk =  skewness(y) ,
y_ku = kurtosis(y)
)
return(card_stats)
}
keyboard.stats <- getCharStats(keyboard.grouped)
View(keyboard.stats)
15 * 5 * 8
